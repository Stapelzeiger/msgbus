from collections import namedtuple

WhitespaceBlock = namedtuple('WhitespaceBlock', ['nb_lines'])
CommentBlock = namedtuple('CommentBlock', ['comments'])
TypeDefinition = namedtuple('TypeDefinition',
                            ['typename',
                             'docstring',
                             'entries']
                            )
TypeDefinitionEntry = namedtuple('TypeDefinitionEntry',
                                 ['type',
                                  'name',
                                  'docstring']
                                 )


def split_line_in_expression_and_comment(line):
    expr_and_comment = line.split('#', 1)
    expr = expr_and_comment[0].split()
    if len(expr_and_comment) > 1:
        comment = expr_and_comment[1].rstrip()
    else:
        comment = ''
    return (expr, comment)


def is_type_definition(expr):
    return len(expr) == 1 and expr[0].endswith(':')


def parse(numbered_lines):
    line_idx, line = next(numbered_lines)
    expr, comment = split_line_in_expression_and_comment(line)
    while True:
        comments = []
        whitespace_lines = 0
        while not expr:
            if comment and whitespace_lines > 0:
                yield WhitespaceBlock(whitespace_lines)
                whitespace_lines = 0
            if not comment and comments:
                yield CommentBlock(comments)
                comments = []
            if comment:
                comments.append(comment)
            else:
                whitespace_lines += 1
            try:
                line_idx, line = next(numbered_lines)
            except StopIteration:
                if whitespace_lines > 0:
                    yield WhitespaceBlock(whitespace_lines)
                if comments:
                    yield CommentBlock(comments)
                raise StopIteration
            expr, comment = split_line_in_expression_and_comment(line)

        if whitespace_lines > 0:
            yield WhitespaceBlock(whitespace_lines)

        if is_type_definition(expr):
            if comment:
                comments.append(comment)
            name = expr[0].rstrip(':')
            entries = []
            while True:
                try:
                    line_idx, line = next(numbered_lines)
                except StopIteration:
                    yield TypeDefinition(name, comments, entries)
                    raise StopIteration
                expr, comment = split_line_in_expression_and_comment(line)
                if len(expr) == 2 and ':' not in expr[0]:
                    entries.append(TypeDefinitionEntry(expr[0], expr[1], comment))
                else:
                    yield TypeDefinition(name, comments, entries)
                    break
        else:
            raise Exception("line {}: unknown expression {}".format(line_idx+1, expr))


def parse_file(file):
    return list(parse(enumerate(file)))


def generate_C_comment_block(comments, doxygen=False):
    out = []
    if doxygen:
        start = '/**'
        indent = ' * '
    else:
        start = '/*'
        indent = ' *'
    out.append(start + comments[0])
    out += [indent + c for c in comments[1:]]
    if len(out) > 1:
        out.append(' */')
    else:
        out[0] += ' */'
    return out


def generate_C_struct_definition(typedef):
    out = []
    if typedef.docstring:
        out += generate_C_comment_block(typedef.docstring, doxygen=True)
    out.append('typedef struct {')
    for e in typedef.entries:
        if e.docstring:
            doc = '  /**<{} */'.format(e.docstring)
        else:
            doc = ''
        out.append('    {} {};{}'.format(e.type, e.name, doc))
    out.append('}} {}_t;'.format(typedef.typename))
    return out


def generate_C_type_definition_header(typedef):
    return ['extern const messagebus_type_definition_t {}_type;'.format(typedef.typename)]


def generate_C_header(filename, elements):
    out = []
    out.append('/* THIS FILE IS AUTOMATICALLY GENERATED */')
    headerguard = filename.upper() + '_H'
    out.append('#ifndef ' + headerguard)
    out.append('#define ' + headerguard)
    out.append('')
    for e in elements:
        if type(e) is CommentBlock:
            out += generate_C_comment_block(e.comments)
        if type(e) is WhitespaceBlock:
            out += [''] * e.nb_lines
        if type(e) is TypeDefinition:
            out += generate_C_struct_definition(e)

    out.append('')
    out.append('/* messagebus type definitions */')
    typedefs = [e for e in elements if type(e) is TypeDefinition]
    for t in typedefs:
        out += generate_C_type_definition_header(t)
    out.append('')
    out.append('#endif /* ' + headerguard + ' */')

    return '\n'.join(out)


def generate_C_type_definition(typedef):
    out = []
    nb_elements = 0
    out.append('const messagebus_entry_t {}_entries[] = {{'.format(typedef.typename))
    for e in typedef.entries:
        nb_elements += 1
        out.append('    {')
        out.append('        .name = "{}",'.format(e.name))
        out.append('        .is_base_type = 1,')
        out.append('        .is_array = 0,')
        out.append('        .is_dynamic_array = 0,')
        out.append('        .array_len = 0,')
        out.append('        .dynamic_array_len_struct_offset = 0,')
        out.append('        .struct_offset = offestof({}_t, {}),'.format(typedef.typename, e.name))
        out.append('        .base_type = {},'.format(e.type))
        out.append('        .size = sizeof({}),'.format(e.type))
        out.append('    },')
    out.append('};')
    out.append('')
    out.append('const messagebus_type_definition_t {}_type = {{'.format(typedef.typename))
    out.append('    .nb_elements = {}'.format(nb_elements))
    out.append('    .elements = {}_entries'.format(typedef.typename))
    out.append('};')
    return out


def generate_C_type_definition_header(typedef):
    return ['extern const messagebus_type_definition_t {}_type;'.format(typedef.typename)]

def generate_C_source(filename, elements):
    out = []
    out.append('/* THIS FILE IS AUTOMATICALLY GENERATED */')
    out.append('#include <msgbus/type_definition.h>'.format(filename))
    out.append('#include "{}.h"'.format(filename))
    out.append('')
    for e in elements:
        if type(e) is TypeDefinition:
            out += generate_C_type_definition(e)
            out.append('')


    return '\n'.join(out)

if __name__ == '__main__':
    f = open('example.type')
    t = parse_file(f)
    # print(generate_C_header('example', t))
    print(generate_C_source('example', t))
